# C++ Network Library



## 项目介绍

本项目是参考 muduo 实现的基于 Reactor 模型的多线程网络库。使用新版C++编写，去除 muduo 对 boost 的依赖。

## 项目特点

- 底层使用EPOLL模式，结合非阻塞 I/O  实现主从 Reactor 模型；
- 基于红黑树实现定时器结构，内部使用 Linux  timerfd 通知到期任务，采用惰性删除实现O(1)复杂度取消定时任务，经测试比muduo定时器性能更强，并发性更好；
- 使用智能指针管理内存，控制对象的生命周期；
- 实现Redis数据库连接池，减少连接数据库的开销，使用参数化语句，防止注入攻击；
- 使用右值移动、完美转发等方法实现高性能线程池，支持任意参数和返回值；
- 支持HTTP协议，利用有限状态机解析 HTTP 请求报文；

## 开发环境

- 操作系统：`Ubuntu 20.04`
- 编译器：`g++ 11.3.0`
- 版本控制：`git`
- 项目构建：`cmake 3.24.3`



## IO多路复用

io多路复用是合理利用CPU资源的方法

对于单线程程序，如果采用同步阻塞IO模型，在整个IO请求的过程中，线程是被阻塞的，不能做其他任何事情，只能为一个客户使用，对CPU的资源利用率不够。如果采用同步非阻塞IO模型，需要不断地轮询、重复请求，消耗了大量的CPU的资源，故这种模型也是不合理的。而IO多路复用模型，在没有需求的时候就会阻塞，降低CPU利用率，而任意需求到来时，就会唤醒IO线程，对请求进行处理

Linux有三种IO复用接口 select，poll，epoll

#### select

select调用时，首先把fd_set拷贝到内核，然后遍历fd_set，如果有IO事件就设置对应用户态fd_set中的fd，没有就阻塞，直到有IO事件或超时。

用户检查IO事件的时候也要遍历fd_set，通过FD_ISSET宏来判断某个fd是否有IO事件。也就是说select不返回一个有IO事件的set，而是通过设置用户态中fd_set中某个fd的标志位来通知用户有IO事件

缺点

+ 涉及到用户态到内核态的内存拷贝，消耗大
+ 用户检查时要遍历所有fd，尽管多个fd中只有一个fd有IO事件
+ 监听fd数量有限
+ 若监听fd最小值为min，最大值为max，检查时就要把min到max中的所有描述符都检查一遍

#### poll

poll和select类似，只不过poll用数组保存要监听描述符，检查时只要遍历数组

#### epoll

+ 执行epoll_create会创建一个红黑树和一个就绪链表，链表保存就绪的事件
+ 加入监听fd，会往红黑树插入fd，然后注册一个回调函数，当fd有IO事件会调用回调函数，将fd放入就绪链表中
+ 返回时，通过将就绪链表的fd移动到数组中返回给用户，通过mmap共享数组内存避免拷贝

## 主从Reactor模式

项目采用主从 Reactor 模型，MainReactor 只负责监听派发新连接，在 mainReactor 中通过 Acceptor 接收新连接并轮询派发给 SubReactor，SubReactor 负责此连接的读写事件。

TcpServer 会内部创建线程池。每个线程独立的运行一个事件循环，即 subReactor。mainReactor 从线程池中轮询获取 subReactor并派发给它新连接，由subReactor处理读写事件。

使用主从 Reactor 模型有诸多优点：

1. 响应快，不必为单个同步事件所阻塞，虽然 Reactor 本身依然是同步的；
2. 可以最大程度避免复杂的多线程及同步问题，并且避免多线程/进程的切换；
3. 扩展性好，可以方便通过增加 Reactor 实例个数充分利用 CPU 资源；
4. 复用性好，Reactor 模型本身与具体事件处理逻辑无关，具有很高的复用性；



## 模块介绍

[Channel模块](./模块讲解/Channel模块.md)

[Poller模块](./模块讲解/Poller模块.md)

[定时器模块](./模块讲解/定时器模块.md)

[数据库连接池模块](./模块讲解/数据库连接池模块.md)

[线程池模块](./模块讲解/线程池模块.md)

...

2023/2/17